# T3.2 Summary: Topology Semantics

## What

Implemented and enforced topology routing rules at multiple layers:
1. **Router-side TopologyGuard** (`apex/runtime/topology_guard.py`): Authoritative enforcement
2. **Agent-level awareness**: Agents adapt routing based on active topology
3. **Three topology modes**: Star, Chain, and Flat with specific routing constraints

## How

### TopologyGuard Design

```python
class TopologyGuard:
    def validate_pair(self, topology: str, sender: AgentID, recipient: AgentID) -> None
    def validate_broadcast(self, topology: str, sender: AgentID, recipient_count: int) -> None
```

### Integration Point

Router integration at `apex/runtime/router.py` lines 135-161:
```python
async def route(self, msg: Message) -> bool:
    # Get current topology for validation (read once per call)
    topology = None
    if self._switch_engine:
        topology, _ = self._switch_engine.active()
    
    # Validate the pair before routing
    if topology and self._topology_guard:
        self._topology_guard.validate_pair(topology, msg.sender, msg.recipient)
```

### Exact Topology Rules

#### Star Topology (`_validate_star`, lines 75-86)
- **Allowed**: 
  - Non-planner → Planner (spokes to hub)
  - Planner → Any agent (hub to spokes)
- **Blocked**: Non-planner → Non-planner
- **Exception raised**: `TopologyViolationError` with descriptive message

#### Chain Topology (`_validate_chain`, lines 88-113)
- **With Summarizer**: P→C→R→Cr→S→P
- **Without Summarizer**: P→C→R→Cr→P  
- **Blocked**: Any pair not in strict order
- **Exception raised**: `TopologyViolationError` for invalid hops

#### Flat Topology (`_validate_flat`, lines 115-121)
- **Allowed**: All peer-to-peer pairs
- **Fanout limit**: ≤ 2 recipients for broadcast
- **Validation**: Broadcast fanout checked in `validate_broadcast`

### Special Cases

1. **System messages**: Always allowed (line 46) for kickoff messages
2. **Broadcast handling**: Validates both fanout count and individual pairs
3. **Unknown topologies**: Pass through without validation (neutral)

## Why

### Defense in Depth
- **Layer 1**: Agents check topology and route appropriately
- **Layer 2**: Router TopologyGuard rejects violations (authoritative)
- **Layer 3**: A2A protocol enforcement (already implemented)

### Design Rationale

1. **Guard in Router not IRouter**: Keeps protocol interface clean while adding enforcement in concrete implementation

2. **Topology read once per route()**: Ensures consistency within single routing decision

3. **Exceptions over silent drops**: Clear feedback when topology rules violated

## Evidence from Traces

### Star Topology Enforcement
From test output - illegal hop rejected:
```python
with pytest.raises(TopologyViolationError):
    illegal_msg = Message(
        sender=AgentID("coder"),
        recipient=AgentID("runner"),  # Illegal: non-planner to non-planner
```
Result: `TopologyViolationError: Star topology violation: coder → runner`

### Chain Order Verification
Trace analysis from `agents_chain_trace.jsonl`:
- Total messages: 20
- Valid chain edges found: {('planner', 'coder'), ('coder', 'runner'), ('runner', 'critic'), ('critic', 'summarizer'), ('summarizer', 'planner')}
- Invalid edges rejected: 1 (test case for coder→critic)

### Flat Fanout Bound
Test attempted BROADCAST to 4 recipients (exceeds limit of 2):
```python
TopologyViolationError: Flat topology fanout 4 exceeds limit 2
```

## Ingress Epoch Note

**Fallback used**: Since `ISwitchEngine.ingress_epoch()` not found in codebase, implementation uses `switch.active()[1]` for epoch stamping. This is flagged in `BaseAgent._new_msg()` at line 48:
```python
def _new_msg(self, recipient: AgentID, payload: dict) -> Message:
    """Uses switch.active()[1] since ingress_epoch() is not available."""
    topology, epoch = self.switch.active()
```

## Test Results

```bash
$ pytest -q tests/test_agents_star_end_to_end.py
.                                                                        [100%]

$ pytest -q tests/test_agents_chain_end_to_end.py  
.                                                                        [100%]

$ pytest -q tests/test_agents_flat_end_to_end.py
.                                                                        [100%]

$ pytest -q tests/test_agents_switch_mid_episode.py
.                                                                        [100%]
```

All tests pass with:
- Episodes complete in ≤ 20 steps
- Topology rules enforced correctly
- No epoch gating violations during switch
- JSONL artifacts generated successfully