# T4.2: Reward Design & Logging Summary

## Reward Formula

Per-step reward components (deterministic):

| Component | Value | Condition |
|-----------|-------|-----------|
| Phase advancement | +0.3 | When phase transitions forward (e.g., planning→coding) |
| Test improvement | +0.7 × Δ test_pass_rate | Scaled by test pass rate delta |
| Token cost | -1e-4 × Δ tokens | Penalty for token usage |
| Switch cost | -0.05 | When topology switch commits |
| Terminal bonus | +1.0 | If all tests pass at episode end |

## Implementation

### RewardAccumulator (`apex/controller/reward.py`)

```python
class RewardAccumulator:
    def step_reward(self, prev: dict, curr: dict) -> float:
        """Compute per-step reward from state transition"""
        
    def final_bonus(self, success: bool) -> float:
        """Terminal bonus: 1.0 if success, 0.0 otherwise"""
```

### Phase Detection

Two methods implemented:

1. **Explicit phase tracking**: Uses phase names with defined ordering:
   - `["planning", "coding", "testing", "critique", "done"]`
   - Advancement detected when curr_idx > prev_idx

2. **Role share transitions**: Detects phase changes via dominant role shifts:
   - planner → coder_runner: Planning → Coding
   - coder_runner → critic: Coding → Testing/Critique
   - critic → planner: Critique → New iteration

## Reward Logging

JSONL format at `docs/A4/artifacts/rewards.jsonl`:

```json
{
  "step": 7,
  "delta_pass_rate": 0.1,
  "delta_tokens": 200,
  "phase_advance": true,
  "switch_committed": false,
  "r_step": 0.35
}
```

Fields:
- `step`: Decision step number
- `delta_pass_rate`: Change in test pass rate
- `delta_tokens`: Token usage delta
- `phase_advance`: Boolean for phase transition
- `switch_committed`: Whether topology switched
- `r_step`: Computed step reward

## Test Scenario Results

From `test_reward_logging.py`, simulated 25-step episode:

```
Phase transitions: 7 (planning→coding→testing→critique→coding→testing→done)
Test pass rate: 0.0 → 1.0
Tokens used: 0 → 3500
Switches: 2 (at steps 9 and 16)
Terminal bonus: 1.0 (success)
```

Sample JSONL lines from artifact:

```json
{"step": 5, "delta_pass_rate": 0.0, "delta_tokens": 50, "phase_advance": true, "switch_committed": false, "r_step": 0.295}
{"step": 9, "delta_pass_rate": 0.0, "delta_tokens": 200, "phase_advance": false, "switch_committed": true, "r_step": -0.07}
{"step": 14, "delta_pass_rate": 0.1, "delta_tokens": 150, "phase_advance": false, "switch_committed": false, "r_step": 0.055}
{"step": 25, "delta_pass_rate": 0.05, "delta_tokens": 100, "phase_advance": true, "switch_committed": false, "r_step": 0.325}
{"step": 26, "delta_pass_rate": 0, "delta_tokens": 0, "phase_advance": false, "switch_committed": false, "r_step": 1.0, "terminal": true}
```

## Design Rationale

**Reward Constants:**
- Phase advancement (+0.3): Encourages task progression
- Test improvement (+0.7×): Strongly rewards quality improvements
- Token cost (-1e-4×): Minor penalty to discourage waste
- Switch cost (-0.05): Small deterrent for excessive switching
- Terminal bonus (+1.0): Major incentive for task completion

**Delta Computation:**
- All rewards based on state transitions (prev → curr)
- Enables credit assignment for specific actions
- Token/test deltas computed from absolute values in state dicts

## Deviations/Assumptions

1. **Phase detection proxy**: In tests without full task execution, we simulate phases via message patterns and explicitly track phase names. In production, would detect via actual task state changes.

2. **Test pass rate simulation**: Tests use synthetic pass rates that increment during "testing" phase. Real implementation would read from test adapter results.

3. **Token counting**: Tests simulate token usage with fixed increments. Production would read actual LLM token counts from adapters.

## Test Commands

```bash
pip install -e ".[dev]"
pytest -q tests/test_reward_logging.py
```

## Artifact Schemas

### controller_decisions.jsonl
```json
{
  "step": int,
  "topology": str,
  "x": list[float],  // 8-feature vector
  "action": str,      // "stay"/"star"/"chain"/"flat"
  "epsilon": float,
  "ms": float,
  "switch": {
    "attempted": bool,
    "committed": bool,
    "epoch": int,
    "error": str (optional)
  },
  "topology_after": str (optional)
}
```

### rewards.jsonl
```json
{
  "step": int,
  "delta_pass_rate": float,
  "delta_tokens": int,
  "phase_advance": bool,
  "switch_committed": bool,
  "r_step": float,
  "terminal": bool (optional)
}
```

### controller_latency.jsonl
```json
{
  "i": int,  // decision index
  "ms": float  // decision latency in milliseconds
}
```

## Code References

- Reward computation: `apex/controller/reward.py:22-71`
- Phase detection: `apex/controller/reward.py:73-102`
- Role share detection: `apex/controller/reward.py:104-127`
- Reward logging test: `tests/test_reward_logging.py:115-215`
- Controller integration: `apex/controller/controller.py:96-122`