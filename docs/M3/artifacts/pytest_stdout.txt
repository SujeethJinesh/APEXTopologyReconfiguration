============================= test session starts ==============================
platform darwin -- Python 3.11.6, pytest-8.4.1, pluggy-1.6.0
rootdir: /Users/sujeethjinesh/Desktop/APEXTopologyReconfiguration
configfile: pyproject.toml
plugins: asyncio-1.1.0, anyio-4.9.0, langsmith-0.4.1, cov-6.2.1
asyncio: mode=Mode.STRICT, asyncio_default_fixture_loop_scope=None, asyncio_default_test_loop_scope=function
collected 109 items

tests/test_a2a_chain_topology.py ......F.FF                              [  9%]
tests/test_a2a_flat_topology.py ..........                               [ 18%]
tests/test_a2a_ingress_chain_enforcement.py ..........                   [ 27%]
tests/test_a2a_ingress_epoch_gating.py ss...                             [ 32%]
tests/test_a2a_ingress_topology_switch.py ......                         [ 37%]
tests/test_a2a_sdk_integration.py ..F...F                                [ 44%]
tests/test_a2a_sdk_optional_imports.py sss...                            [ 49%]
tests/test_a2a_star_topology.py ........                                 [ 56%]
tests/test_a2a_topology_switch_runtime.py .......                        [ 63%]
tests/test_coordinator_dwell_cooldown.py ..                              [ 65%]
tests/test_defaults_config.py .                                          [ 66%]
tests/test_docs_m0_summaries.py .                                        [ 66%]
tests/test_evidence_pack_presence.py .                                   [ 67%]
tests/test_fs_local_whitelist_patch_search.py ....                       [ 71%]
tests/test_llm_http_client.py ....                                       [ 75%]
tests/test_makefile_targets.py .                                         [ 76%]
tests/test_mcp_fastmcp_wrappers.py ......s..                             [ 84%]
tests/test_mcp_traversal_denial.py ......                                [ 89%]
tests/test_message_dataclass.py .                                        [ 90%]
tests/test_msg_id_uniqueness_10k.py .                                    [ 91%]
tests/test_precommit_config.py .                                         [ 92%]
tests/test_protocols_importable.py .                                     [ 93%]
tests/test_pytest_adapter_discover_run.py .                              [ 94%]
tests/test_router_fifo_ttl_retry.py ...                                  [ 97%]
tests/test_switch_epoch_gating_atomic.py ...                             [100%]

=================================== FAILURES ===================================
_______ TestErrorEnvelopes.test_invalid_recipient_returns_error_envelope _______

self = <test_a2a_chain_topology.TestErrorEnvelopes object at 0x10e3a7a90>
router = <AsyncMock spec='Router' id='4567526096'>
switch = <MagicMock spec='SwitchEngine' id='4567581968'>

    @pytest.mark.asyncio
    async def test_invalid_recipient_returns_error_envelope(self, router, switch):
        """Test InvalidRecipientError returns A2A error envelope."""
        protocol = A2AProtocol(router, switch, topology="star")
    
        # Make router raise InvalidRecipientError
        router.route.side_effect = InvalidRecipientError("unknown_agent")
    
>       result = await protocol.send(sender="planner", recipient="unknown_agent", content="test")
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_a2a_chain_topology.py:176: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <apex.a2a.protocol.A2AProtocol object at 0x1103fe110>, sender = 'planner'
recipient = 'unknown_agent', recipients = None, content = 'test'
force_topology = None

    async def send(
        self,
        sender: str,
        recipient: Optional[str] = None,
        recipients: Optional[list[str]] = None,
        content: str = "",
        force_topology: Optional[str] = None,
    ) -> dict:
        """Send a message with topology enforcement.
    
        Args:
            sender: Sender agent ID
            recipient: Single recipient (for star/chain)
            recipients: Multiple recipients (for flat)
            content: Message content
            force_topology: Override topology for testing (default: use switch active)
    
        Returns:
            dict: A2A-compliant envelope of sent message
    
        Raises:
            ValueError: If topology rules are violated
        """
        # Get active topology from switch (dynamic!)
        active_topology, epoch = self.switch.active()
    
        # Allow test override, otherwise use active topology
        topology = force_topology if force_topology else active_topology
    
        # Build message(s) based on active topology
        messages = []
    
        if topology == "star":
            # Star topology: requires single recipient (not recipients list)
            if not recipient:
                raise ValueError("Star topology requires recipient")
            if recipients:
                raise ValueError("Star topology requires recipient, not recipients list")
    
            # Star topology: all non-planner communicate through planner
            if sender != self.planner_id and recipient != self.planner_id:
                # Non-planner must route through planner
                messages.append(
                    Message(
                        episode_id="a2a-episode",
                        msg_id=f"msg-{uuid4().hex}",
                        sender=sender,
                        recipient=self.planner_id,
                        topo_epoch=epoch,
                        payload={"content": content},
                    )
                )
            else:
                # Planner involved: direct send
                messages.append(
                    Message(
                        episode_id="a2a-episode",
                        msg_id=f"msg-{uuid4().hex}",
                        sender=sender,
                        recipient=recipient,
                        topo_epoch=epoch,
                        payload={"content": content},
                    )
                )
    
        elif topology == "chain":
            # Chain topology: sequential processing with next-hop enforcement
            if not recipient:
                raise ValueError("Chain topology requires recipient")
    
            # Enforce next-hop semantics
            expected_next = self.chain_next.get(sender)
            if expected_next and recipient != expected_next:
>               raise ValueError(
                    f"Chain topology violation: {sender} must send to "
                    f"{expected_next}, not {recipient}"
                )
E               ValueError: Chain topology violation: planner must send to coder, not unknown_agent

apex/a2a/protocol.py:140: ValueError
_____________ TestFlatTopologyFanout.test_fanout_at_limit_succeeds _____________

self = <test_a2a_chain_topology.TestFlatTopologyFanout object at 0x10e3b4f10>
router = <AsyncMock spec='Router' id='4568116816'>
switch = <MagicMock spec='SwitchEngine' id='4544071824'>

    @pytest.mark.asyncio
    async def test_fanout_at_limit_succeeds(self, router, switch):
        """Test fanout exactly at limit works."""
        protocol = A2AProtocol(router, switch, topology="flat", fanout_limit=2)
    
>       result = await protocol.send(
            sender="planner", recipients=["coder", "runner"], content="broadcast"  # Exactly 2
        )

tests/test_a2a_chain_topology.py:209: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <apex.a2a.protocol.A2AProtocol object at 0x11042fbd0>, sender = 'planner'
recipient = None, recipients = ['coder', 'runner'], content = 'broadcast'
force_topology = None

    async def send(
        self,
        sender: str,
        recipient: Optional[str] = None,
        recipients: Optional[list[str]] = None,
        content: str = "",
        force_topology: Optional[str] = None,
    ) -> dict:
        """Send a message with topology enforcement.
    
        Args:
            sender: Sender agent ID
            recipient: Single recipient (for star/chain)
            recipients: Multiple recipients (for flat)
            content: Message content
            force_topology: Override topology for testing (default: use switch active)
    
        Returns:
            dict: A2A-compliant envelope of sent message
    
        Raises:
            ValueError: If topology rules are violated
        """
        # Get active topology from switch (dynamic!)
        active_topology, epoch = self.switch.active()
    
        # Allow test override, otherwise use active topology
        topology = force_topology if force_topology else active_topology
    
        # Build message(s) based on active topology
        messages = []
    
        if topology == "star":
            # Star topology: requires single recipient (not recipients list)
            if not recipient:
                raise ValueError("Star topology requires recipient")
            if recipients:
                raise ValueError("Star topology requires recipient, not recipients list")
    
            # Star topology: all non-planner communicate through planner
            if sender != self.planner_id and recipient != self.planner_id:
                # Non-planner must route through planner
                messages.append(
                    Message(
                        episode_id="a2a-episode",
                        msg_id=f"msg-{uuid4().hex}",
                        sender=sender,
                        recipient=self.planner_id,
                        topo_epoch=epoch,
                        payload={"content": content},
                    )
                )
            else:
                # Planner involved: direct send
                messages.append(
                    Message(
                        episode_id="a2a-episode",
                        msg_id=f"msg-{uuid4().hex}",
                        sender=sender,
                        recipient=recipient,
                        topo_epoch=epoch,
                        payload={"content": content},
                    )
                )
    
        elif topology == "chain":
            # Chain topology: sequential processing with next-hop enforcement
            if not recipient:
>               raise ValueError("Chain topology requires recipient")
E               ValueError: Chain topology requires recipient

apex/a2a/protocol.py:135: ValueError
___________ TestFlatTopologyFanout.test_fanout_exceeds_limit_raises ____________

self = <test_a2a_chain_topology.TestFlatTopologyFanout object at 0x10e3b5810>
router = <AsyncMock spec='Router' id='4568305296'>
switch = <MagicMock spec='SwitchEngine' id='4568263824'>

    @pytest.mark.asyncio
    async def test_fanout_exceeds_limit_raises(self, router, switch):
        """Test fanout over limit raises with exact message."""
        protocol = A2AProtocol(router, switch, topology="flat", fanout_limit=2)
    
        with pytest.raises(ValueError) as exc_info:
            await protocol.send(
                sender="planner",
                recipients=["coder", "runner", "critic"],  # 3 > 2
                content="broadcast",
            )
    
        # Check exact error message
>       assert "Recipients exceed fanout limit of 2" in str(exc_info.value)
E       AssertionError: assert 'Recipients exceed fanout limit of 2' in 'Chain topology requires recipient'
E        +  where 'Chain topology requires recipient' = str(ValueError('Chain topology requires recipient'))
E        +    where ValueError('Chain topology requires recipient') = <ExceptionInfo ValueError('Chain topology requires recipient') tblen=2>.value

tests/test_a2a_chain_topology.py:230: AssertionError
__________ TestA2AEnvelopeAndRouting.test_flat_topology_fanout_limit ___________

self = <test_a2a_sdk_integration.TestA2AEnvelopeAndRouting object at 0x10e3ea8d0>
router = <AsyncMock spec='Router' id='4568627792'>
switch = <MagicMock spec='SwitchEngine' id='4568613328'>

    @pytest.mark.asyncio
    @pytest.mark.asyncio
    async def test_flat_topology_fanout_limit(self, router, switch):
        """Test flat topology enforces fanout limit."""
        protocol = A2AProtocol(router, switch, topology="flat", fanout_limit=2)
    
        # Try to exceed fanout
        with pytest.raises(ValueError, match="exceed fanout limit"):
>           await protocol.send(
                sender="planner",
                recipients=["coder", "runner", "critic"],  # 3 > limit of 2
                content="Broadcast",
            )

tests/test_a2a_sdk_integration.py:89: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <apex.a2a.protocol.A2AProtocol object at 0x1103ed6d0>, sender = 'planner'
recipient = None, recipients = ['coder', 'runner', 'critic']
content = 'Broadcast', force_topology = None

    async def send(
        self,
        sender: str,
        recipient: Optional[str] = None,
        recipients: Optional[list[str]] = None,
        content: str = "",
        force_topology: Optional[str] = None,
    ) -> dict:
        """Send a message with topology enforcement.
    
        Args:
            sender: Sender agent ID
            recipient: Single recipient (for star/chain)
            recipients: Multiple recipients (for flat)
            content: Message content
            force_topology: Override topology for testing (default: use switch active)
    
        Returns:
            dict: A2A-compliant envelope of sent message
    
        Raises:
            ValueError: If topology rules are violated
        """
        # Get active topology from switch (dynamic!)
        active_topology, epoch = self.switch.active()
    
        # Allow test override, otherwise use active topology
        topology = force_topology if force_topology else active_topology
    
        # Build message(s) based on active topology
        messages = []
    
        if topology == "star":
            # Star topology: requires single recipient (not recipients list)
            if not recipient:
>               raise ValueError("Star topology requires recipient")
E               ValueError: Star topology requires recipient

apex/a2a/protocol.py:102: ValueError

During handling of the above exception, another exception occurred:

self = <test_a2a_sdk_integration.TestA2AEnvelopeAndRouting object at 0x10e3ea8d0>
router = <AsyncMock spec='Router' id='4568627792'>
switch = <MagicMock spec='SwitchEngine' id='4568613328'>

    @pytest.mark.asyncio
    @pytest.mark.asyncio
    async def test_flat_topology_fanout_limit(self, router, switch):
        """Test flat topology enforces fanout limit."""
        protocol = A2AProtocol(router, switch, topology="flat", fanout_limit=2)
    
        # Try to exceed fanout
>       with pytest.raises(ValueError, match="exceed fanout limit"):
E       AssertionError: Regex pattern did not match.
E        Regex: 'exceed fanout limit'
E        Input: 'Star topology requires recipient'

tests/test_a2a_sdk_integration.py:88: AssertionError
____________ TestA2ACompliance.test_from_a2a_request_flat_topology _____________

self = <test_a2a_sdk_integration.TestA2ACompliance object at 0x10e3f8c10>
router = <AsyncMock spec='Router' id='4543837712'>
switch = <MagicMock spec='SwitchEngine' id='4543830480'>

    @pytest.mark.asyncio
    async def test_from_a2a_request_flat_topology(self, router, switch):
        """Test A2A request with flat topology (broadcast)."""
        compliance = A2ACompliance(
            router, switch, roles=["planner", "coder", "runner"], fanout_limit=3
        )
    
        request = {
            "method": "send",
            "params": {
                "sender": "planner",
                "recipients": ["coder", "runner"],
                "content": "Broadcast message",
                "metadata": {"topology": "flat"},
            },
        }
    
        messages = compliance.from_a2a_request(request)
    
>       assert len(messages) == 2
E       assert 0 == 2
E        +  where 0 = len([])

tests/test_a2a_sdk_integration.py:197: AssertionError
=============================== warnings summary ===============================
apex/integrations/mcp/test_api.py:6
  /Users/sujeethjinesh/Desktop/APEXTopologyReconfiguration/apex/integrations/mcp/test_api.py:6: PytestCollectionWarning: cannot collect test class 'Test' because it has a __init__ constructor (from: tests/test_protocols_importable.py)
    class Test(Protocol):

-- Docs: https://docs.pytest.org/en/stable/how-to/capture-warnings.html
- generated xml file: /Users/sujeethjinesh/Desktop/APEXTopologyReconfiguration/docs/M3/artifacts/junit.xml -
=========================== short test summary info ============================
FAILED tests/test_a2a_chain_topology.py::TestErrorEnvelopes::test_invalid_recipient_returns_error_envelope
FAILED tests/test_a2a_chain_topology.py::TestFlatTopologyFanout::test_fanout_at_limit_succeeds
FAILED tests/test_a2a_chain_topology.py::TestFlatTopologyFanout::test_fanout_exceeds_limit_raises
FAILED tests/test_a2a_sdk_integration.py::TestA2AEnvelopeAndRouting::test_flat_topology_fanout_limit
FAILED tests/test_a2a_sdk_integration.py::TestA2ACompliance::test_from_a2a_request_flat_topology
============== 5 failed, 98 passed, 6 skipped, 1 warning in 3.96s ==============
