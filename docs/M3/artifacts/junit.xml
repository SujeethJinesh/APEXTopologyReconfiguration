<?xml version="1.0" encoding="utf-8"?><testsuites name="pytest tests"><testsuite name="pytest" errors="0" failures="5" skipped="6" tests="109" time="3.960" timestamp="2025-08-21T23:21:09.838704-07:00" hostname="Sujeeths-MacBook-Pro.local"><testcase classname="tests.test_a2a_chain_topology.TestChainTopologyEnforcement" name="test_valid_chain_transitions" time="0.006" /><testcase classname="tests.test_a2a_chain_topology.TestChainTopologyEnforcement" name="test_invalid_chain_transitions_raise" time="0.003" /><testcase classname="tests.test_a2a_chain_topology.TestChainTopologyEnforcement" name="test_chain_requires_recipient" time="0.003" /><testcase classname="tests.test_a2a_chain_topology.TestChainTopologyEnforcement" name="test_chain_messages_have_correct_fields" time="0.003" /><testcase classname="tests.test_a2a_chain_topology.TestMessageIdUniqueness" name="test_msg_id_unique_for_identical_content" time="0.348" /><testcase classname="tests.test_a2a_chain_topology.TestMessageIdUniqueness" name="test_msg_id_format_is_uuid_hex" time="0.003" /><testcase classname="tests.test_a2a_chain_topology.TestErrorEnvelopes" name="test_invalid_recipient_returns_error_envelope" time="0.003"><failure message="ValueError: Chain topology violation: planner must send to coder, not unknown_agent">self = &lt;test_a2a_chain_topology.TestErrorEnvelopes object at 0x10e3a7a90&gt;
router = &lt;AsyncMock spec='Router' id='4567526096'&gt;
switch = &lt;MagicMock spec='SwitchEngine' id='4567581968'&gt;

    @pytest.mark.asyncio
    async def test_invalid_recipient_returns_error_envelope(self, router, switch):
        """Test InvalidRecipientError returns A2A error envelope."""
        protocol = A2AProtocol(router, switch, topology="star")
    
        # Make router raise InvalidRecipientError
        router.route.side_effect = InvalidRecipientError("unknown_agent")
    
&gt;       result = await protocol.send(sender="planner", recipient="unknown_agent", content="test")
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_a2a_chain_topology.py:176: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;apex.a2a.protocol.A2AProtocol object at 0x1103fe110&gt;, sender = 'planner'
recipient = 'unknown_agent', recipients = None, content = 'test'
force_topology = None

    async def send(
        self,
        sender: str,
        recipient: Optional[str] = None,
        recipients: Optional[list[str]] = None,
        content: str = "",
        force_topology: Optional[str] = None,
    ) -&gt; dict:
        """Send a message with topology enforcement.
    
        Args:
            sender: Sender agent ID
            recipient: Single recipient (for star/chain)
            recipients: Multiple recipients (for flat)
            content: Message content
            force_topology: Override topology for testing (default: use switch active)
    
        Returns:
            dict: A2A-compliant envelope of sent message
    
        Raises:
            ValueError: If topology rules are violated
        """
        # Get active topology from switch (dynamic!)
        active_topology, epoch = self.switch.active()
    
        # Allow test override, otherwise use active topology
        topology = force_topology if force_topology else active_topology
    
        # Build message(s) based on active topology
        messages = []
    
        if topology == "star":
            # Star topology: requires single recipient (not recipients list)
            if not recipient:
                raise ValueError("Star topology requires recipient")
            if recipients:
                raise ValueError("Star topology requires recipient, not recipients list")
    
            # Star topology: all non-planner communicate through planner
            if sender != self.planner_id and recipient != self.planner_id:
                # Non-planner must route through planner
                messages.append(
                    Message(
                        episode_id="a2a-episode",
                        msg_id=f"msg-{uuid4().hex}",
                        sender=sender,
                        recipient=self.planner_id,
                        topo_epoch=epoch,
                        payload={"content": content},
                    )
                )
            else:
                # Planner involved: direct send
                messages.append(
                    Message(
                        episode_id="a2a-episode",
                        msg_id=f"msg-{uuid4().hex}",
                        sender=sender,
                        recipient=recipient,
                        topo_epoch=epoch,
                        payload={"content": content},
                    )
                )
    
        elif topology == "chain":
            # Chain topology: sequential processing with next-hop enforcement
            if not recipient:
                raise ValueError("Chain topology requires recipient")
    
            # Enforce next-hop semantics
            expected_next = self.chain_next.get(sender)
            if expected_next and recipient != expected_next:
&gt;               raise ValueError(
                    f"Chain topology violation: {sender} must send to "
                    f"{expected_next}, not {recipient}"
                )
E               ValueError: Chain topology violation: planner must send to coder, not unknown_agent

apex/a2a/protocol.py:140: ValueError</failure></testcase><testcase classname="tests.test_a2a_chain_topology.TestErrorEnvelopes" name="test_queue_full_returns_error_envelope" time="0.002" /><testcase classname="tests.test_a2a_chain_topology.TestFlatTopologyFanout" name="test_fanout_at_limit_succeeds" time="0.003"><failure message="ValueError: Chain topology requires recipient">self = &lt;test_a2a_chain_topology.TestFlatTopologyFanout object at 0x10e3b4f10&gt;
router = &lt;AsyncMock spec='Router' id='4568116816'&gt;
switch = &lt;MagicMock spec='SwitchEngine' id='4544071824'&gt;

    @pytest.mark.asyncio
    async def test_fanout_at_limit_succeeds(self, router, switch):
        """Test fanout exactly at limit works."""
        protocol = A2AProtocol(router, switch, topology="flat", fanout_limit=2)
    
&gt;       result = await protocol.send(
            sender="planner", recipients=["coder", "runner"], content="broadcast"  # Exactly 2
        )

tests/test_a2a_chain_topology.py:209: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;apex.a2a.protocol.A2AProtocol object at 0x11042fbd0&gt;, sender = 'planner'
recipient = None, recipients = ['coder', 'runner'], content = 'broadcast'
force_topology = None

    async def send(
        self,
        sender: str,
        recipient: Optional[str] = None,
        recipients: Optional[list[str]] = None,
        content: str = "",
        force_topology: Optional[str] = None,
    ) -&gt; dict:
        """Send a message with topology enforcement.
    
        Args:
            sender: Sender agent ID
            recipient: Single recipient (for star/chain)
            recipients: Multiple recipients (for flat)
            content: Message content
            force_topology: Override topology for testing (default: use switch active)
    
        Returns:
            dict: A2A-compliant envelope of sent message
    
        Raises:
            ValueError: If topology rules are violated
        """
        # Get active topology from switch (dynamic!)
        active_topology, epoch = self.switch.active()
    
        # Allow test override, otherwise use active topology
        topology = force_topology if force_topology else active_topology
    
        # Build message(s) based on active topology
        messages = []
    
        if topology == "star":
            # Star topology: requires single recipient (not recipients list)
            if not recipient:
                raise ValueError("Star topology requires recipient")
            if recipients:
                raise ValueError("Star topology requires recipient, not recipients list")
    
            # Star topology: all non-planner communicate through planner
            if sender != self.planner_id and recipient != self.planner_id:
                # Non-planner must route through planner
                messages.append(
                    Message(
                        episode_id="a2a-episode",
                        msg_id=f"msg-{uuid4().hex}",
                        sender=sender,
                        recipient=self.planner_id,
                        topo_epoch=epoch,
                        payload={"content": content},
                    )
                )
            else:
                # Planner involved: direct send
                messages.append(
                    Message(
                        episode_id="a2a-episode",
                        msg_id=f"msg-{uuid4().hex}",
                        sender=sender,
                        recipient=recipient,
                        topo_epoch=epoch,
                        payload={"content": content},
                    )
                )
    
        elif topology == "chain":
            # Chain topology: sequential processing with next-hop enforcement
            if not recipient:
&gt;               raise ValueError("Chain topology requires recipient")
E               ValueError: Chain topology requires recipient

apex/a2a/protocol.py:135: ValueError</failure></testcase><testcase classname="tests.test_a2a_chain_topology.TestFlatTopologyFanout" name="test_fanout_exceeds_limit_raises" time="0.002"><failure message="AssertionError: assert 'Recipients exceed fanout limit of 2' in 'Chain topology requires recipient'&#10; +  where 'Chain topology requires recipient' = str(ValueError('Chain topology requires recipient'))&#10; +    where ValueError('Chain topology requires recipient') = &lt;ExceptionInfo ValueError('Chain topology requires recipient') tblen=2&gt;.value">self = &lt;test_a2a_chain_topology.TestFlatTopologyFanout object at 0x10e3b5810&gt;
router = &lt;AsyncMock spec='Router' id='4568305296'&gt;
switch = &lt;MagicMock spec='SwitchEngine' id='4568263824'&gt;

    @pytest.mark.asyncio
    async def test_fanout_exceeds_limit_raises(self, router, switch):
        """Test fanout over limit raises with exact message."""
        protocol = A2AProtocol(router, switch, topology="flat", fanout_limit=2)
    
        with pytest.raises(ValueError) as exc_info:
            await protocol.send(
                sender="planner",
                recipients=["coder", "runner", "critic"],  # 3 &gt; 2
                content="broadcast",
            )
    
        # Check exact error message
&gt;       assert "Recipients exceed fanout limit of 2" in str(exc_info.value)
E       AssertionError: assert 'Recipients exceed fanout limit of 2' in 'Chain topology requires recipient'
E        +  where 'Chain topology requires recipient' = str(ValueError('Chain topology requires recipient'))
E        +    where ValueError('Chain topology requires recipient') = &lt;ExceptionInfo ValueError('Chain topology requires recipient') tblen=2&gt;.value

tests/test_a2a_chain_topology.py:230: AssertionError</failure></testcase><testcase classname="tests.test_a2a_flat_topology.TestFlatTopologyEnforcement" name="test_flat_requires_recipients_list" time="0.002" /><testcase classname="tests.test_a2a_flat_topology.TestFlatTopologyEnforcement" name="test_flat_empty_recipients_raises" time="0.002" /><testcase classname="tests.test_a2a_flat_topology.TestFlatTopologyEnforcement" name="test_flat_fanout_limit_enforced" time="0.003" /><testcase classname="tests.test_a2a_flat_topology.TestFlatTopologyEnforcement" name="test_flat_creates_unique_message_per_recipient" time="0.003" /><testcase classname="tests.test_a2a_flat_topology.TestFlatTopologyEnforcement" name="test_flat_preserves_fifo_order_per_pair" time="0.003" /><testcase classname="tests.test_a2a_flat_topology.TestFlatTopologyEnforcement" name="test_flat_with_single_recipient_in_list" time="0.003" /><testcase classname="tests.test_a2a_flat_topology.TestFlatTopologyEnforcement" name="test_flat_any_sender_allowed" time="0.003" /><testcase classname="tests.test_a2a_flat_topology.TestFlatTopologyEnforcement" name="test_flat_duplicate_recipients_handled" time="0.003" /><testcase classname="tests.test_a2a_flat_topology.TestFlatTopologyEnforcement" name="test_flat_uses_current_epoch" time="0.003" /><testcase classname="tests.test_a2a_flat_topology.TestFlatTopologyEnforcement" name="test_flat_all_messages_same_epoch_per_send" time="0.003" /><testcase classname="tests.test_a2a_ingress_chain_enforcement.TestIngressChainEnforcement" name="test_external_to_planner_allowed" time="0.001" /><testcase classname="tests.test_a2a_ingress_chain_enforcement.TestIngressChainEnforcement" name="test_external_to_runner_rejected" time="0.001" /><testcase classname="tests.test_a2a_ingress_chain_enforcement.TestIngressChainEnforcement" name="test_external_to_critic_rejected" time="0.002" /><testcase classname="tests.test_a2a_ingress_chain_enforcement.TestIngressChainEnforcement" name="test_internal_next_hop_enforced" time="0.001" /><testcase classname="tests.test_a2a_ingress_chain_enforcement.TestIngressChainEnforcement" name="test_internal_backward_hop_rejected" time="0.002" /><testcase classname="tests.test_a2a_ingress_chain_enforcement.TestIngressMessageIdUniqueness" name="test_flat_fanout_unique_msg_ids" time="0.001" /><testcase classname="tests.test_a2a_ingress_chain_enforcement.TestIngressMessageIdUniqueness" name="test_multiple_requests_unique_msg_ids" time="0.003" /><testcase classname="tests.test_a2a_ingress_chain_enforcement.TestIngressMessageIdUniqueness" name="test_msg_id_format_is_uuid" time="0.001" /><testcase classname="tests.test_a2a_ingress_chain_enforcement.TestIngressMessageIdUniqueness" name="test_external_id_preserved_in_payload" time="0.001" /><testcase classname="tests.test_a2a_ingress_chain_enforcement.TestIngressMessageIdUniqueness" name="test_no_external_id_no_preservation" time="0.001" /><testcase classname="tests.test_a2a_ingress_epoch_gating.TestA2AIngressServer" name="test_agent_card_served" time="0.000"><skipped type="pytest.skip" message="A2A ingress disabled in environment">/Users/sujeethjinesh/Desktop/APEXTopologyReconfiguration/tests/test_a2a_ingress_epoch_gating.py:50: A2A ingress disabled in environment</skipped></testcase><testcase classname="tests.test_a2a_ingress_epoch_gating.TestA2AIngressServer" name="test_ingress_send_routes_to_router" time="0.000"><skipped type="pytest.skip" message="A2A ingress disabled in environment">/Users/sujeethjinesh/Desktop/APEXTopologyReconfiguration/tests/test_a2a_ingress_epoch_gating.py:84: A2A ingress disabled in environment</skipped></testcase><testcase classname="tests.test_a2a_ingress_epoch_gating.TestEpochGatingViaIngress" name="test_ingress_during_quiesce_routes_to_next" time="0.003" /><testcase classname="tests.test_a2a_ingress_epoch_gating.TestEpochGatingViaIngress" name="test_no_dequeue_from_next_until_abort" time="0.003" /><testcase classname="tests.test_a2a_ingress_epoch_gating.TestEpochGatingViaIngress" name="test_ingress_error_handling" time="0.003" /><testcase classname="tests.test_a2a_ingress_topology_switch.TestIngressTopologyEnforcement" name="test_ingress_ignores_metadata_topology_claim" time="0.002" /><testcase classname="tests.test_a2a_ingress_topology_switch.TestIngressTopologyEnforcement" name="test_ingress_switches_with_runtime_not_metadata" time="0.002" /><testcase classname="tests.test_a2a_ingress_topology_switch.TestIngressTopologyEnforcement" name="test_ingress_flat_enforced_despite_metadata" time="0.002" /><testcase classname="tests.test_a2a_ingress_topology_switch.TestIngressTopologyEnforcement" name="test_metadata_topology_preserved_as_claimed_not_enforced" time="0.002" /><testcase classname="tests.test_a2a_ingress_topology_switch.TestIngressTopologyEnforcement" name="test_rapid_topology_switches_ignored_in_metadata" time="0.002" /><testcase classname="tests.test_a2a_ingress_topology_switch.TestIngressTopologyEnforcement" name="test_external_chain_ingress_ignores_metadata" time="0.003" /><testcase classname="tests.test_a2a_sdk_integration.TestA2AEnvelopeAndRouting" name="test_send_creates_envelope_and_routes" time="0.002" /><testcase classname="tests.test_a2a_sdk_integration.TestA2AEnvelopeAndRouting" name="test_star_topology_enforcement" time="0.045" /><testcase classname="tests.test_a2a_sdk_integration.TestA2AEnvelopeAndRouting" name="test_flat_topology_fanout_limit" time="0.002"><failure message="AssertionError: Regex pattern did not match.&#10; Regex: 'exceed fanout limit'&#10; Input: 'Star topology requires recipient'">self = &lt;test_a2a_sdk_integration.TestA2AEnvelopeAndRouting object at 0x10e3ea8d0&gt;
router = &lt;AsyncMock spec='Router' id='4568627792'&gt;
switch = &lt;MagicMock spec='SwitchEngine' id='4568613328'&gt;

    @pytest.mark.asyncio
    @pytest.mark.asyncio
    async def test_flat_topology_fanout_limit(self, router, switch):
        """Test flat topology enforces fanout limit."""
        protocol = A2AProtocol(router, switch, topology="flat", fanout_limit=2)
    
        # Try to exceed fanout
        with pytest.raises(ValueError, match="exceed fanout limit"):
&gt;           await protocol.send(
                sender="planner",
                recipients=["coder", "runner", "critic"],  # 3 &gt; limit of 2
                content="Broadcast",
            )

tests/test_a2a_sdk_integration.py:89: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;apex.a2a.protocol.A2AProtocol object at 0x1103ed6d0&gt;, sender = 'planner'
recipient = None, recipients = ['coder', 'runner', 'critic']
content = 'Broadcast', force_topology = None

    async def send(
        self,
        sender: str,
        recipient: Optional[str] = None,
        recipients: Optional[list[str]] = None,
        content: str = "",
        force_topology: Optional[str] = None,
    ) -&gt; dict:
        """Send a message with topology enforcement.
    
        Args:
            sender: Sender agent ID
            recipient: Single recipient (for star/chain)
            recipients: Multiple recipients (for flat)
            content: Message content
            force_topology: Override topology for testing (default: use switch active)
    
        Returns:
            dict: A2A-compliant envelope of sent message
    
        Raises:
            ValueError: If topology rules are violated
        """
        # Get active topology from switch (dynamic!)
        active_topology, epoch = self.switch.active()
    
        # Allow test override, otherwise use active topology
        topology = force_topology if force_topology else active_topology
    
        # Build message(s) based on active topology
        messages = []
    
        if topology == "star":
            # Star topology: requires single recipient (not recipients list)
            if not recipient:
&gt;               raise ValueError("Star topology requires recipient")
E               ValueError: Star topology requires recipient

apex/a2a/protocol.py:102: ValueError

During handling of the above exception, another exception occurred:

self = &lt;test_a2a_sdk_integration.TestA2AEnvelopeAndRouting object at 0x10e3ea8d0&gt;
router = &lt;AsyncMock spec='Router' id='4568627792'&gt;
switch = &lt;MagicMock spec='SwitchEngine' id='4568613328'&gt;

    @pytest.mark.asyncio
    @pytest.mark.asyncio
    async def test_flat_topology_fanout_limit(self, router, switch):
        """Test flat topology enforces fanout limit."""
        protocol = A2AProtocol(router, switch, topology="flat", fanout_limit=2)
    
        # Try to exceed fanout
&gt;       with pytest.raises(ValueError, match="exceed fanout limit"):
E       AssertionError: Regex pattern did not match.
E        Regex: 'exceed fanout limit'
E        Input: 'Star topology requires recipient'

tests/test_a2a_sdk_integration.py:88: AssertionError</failure></testcase><testcase classname="tests.test_a2a_sdk_integration.TestA2ACompliance" name="test_agent_card_generation" time="0.002" /><testcase classname="tests.test_a2a_sdk_integration.TestA2ACompliance" name="test_to_a2a_envelope" time="0.002" /><testcase classname="tests.test_a2a_sdk_integration.TestA2ACompliance" name="test_from_a2a_request_star_topology" time="0.002" /><testcase classname="tests.test_a2a_sdk_integration.TestA2ACompliance" name="test_from_a2a_request_flat_topology" time="0.002"><failure message="assert 0 == 2&#10; +  where 0 = len([])">self = &lt;test_a2a_sdk_integration.TestA2ACompliance object at 0x10e3f8c10&gt;
router = &lt;AsyncMock spec='Router' id='4543837712'&gt;
switch = &lt;MagicMock spec='SwitchEngine' id='4543830480'&gt;

    @pytest.mark.asyncio
    async def test_from_a2a_request_flat_topology(self, router, switch):
        """Test A2A request with flat topology (broadcast)."""
        compliance = A2ACompliance(
            router, switch, roles=["planner", "coder", "runner"], fanout_limit=3
        )
    
        request = {
            "method": "send",
            "params": {
                "sender": "planner",
                "recipients": ["coder", "runner"],
                "content": "Broadcast message",
                "metadata": {"topology": "flat"},
            },
        }
    
        messages = compliance.from_a2a_request(request)
    
&gt;       assert len(messages) == 2
E       assert 0 == 2
E        +  where 0 = len([])

tests/test_a2a_sdk_integration.py:197: AssertionError</failure></testcase><testcase classname="tests.test_a2a_sdk_optional_imports.TestA2ASDKImports" name="test_sdk_imports_correctly" time="0.000"><skipped type="pytest.skip" message="A2A SDK not installed">/Users/sujeethjinesh/Desktop/APEXTopologyReconfiguration/tests/test_a2a_sdk_optional_imports.py:16: A2A SDK not installed</skipped></testcase><testcase classname="tests.test_a2a_sdk_optional_imports.TestA2ASDKImports" name="test_compliance_layer_uses_sdk" time="0.000"><skipped type="pytest.skip" message="A2A SDK not installed">/Users/sujeethjinesh/Desktop/APEXTopologyReconfiguration/tests/test_a2a_sdk_optional_imports.py:32: A2A SDK not installed</skipped></testcase><testcase classname="tests.test_a2a_sdk_optional_imports.TestA2ASDKImports" name="test_agent_card_with_sdk" time="0.000"><skipped type="pytest.skip" message="A2A SDK not installed">/Users/sujeethjinesh/Desktop/APEXTopologyReconfiguration/tests/test_a2a_sdk_optional_imports.py:42: A2A SDK not installed</skipped></testcase><testcase classname="tests.test_a2a_sdk_optional_imports.TestA2AHTTPIngress" name="test_uvicorn_available" time="0.016" /><testcase classname="tests.test_a2a_sdk_optional_imports.TestA2AHTTPIngress" name="test_ingress_start_with_sdk" time="0.004" /><testcase classname="tests.test_a2a_sdk_optional_imports.TestA2AFallback" name="test_compliance_fallback_without_sdk" time="0.001" /><testcase classname="tests.test_a2a_star_topology.TestStarTopologyEnforcement" name="test_non_planner_to_non_planner_routes_via_planner" time="0.003" /><testcase classname="tests.test_a2a_star_topology.TestStarTopologyEnforcement" name="test_planner_to_any_is_direct" time="0.003" /><testcase classname="tests.test_a2a_star_topology.TestStarTopologyEnforcement" name="test_any_to_planner_is_direct" time="0.003" /><testcase classname="tests.test_a2a_star_topology.TestStarTopologyEnforcement" name="test_no_duplicate_messages_per_send" time="0.002" /><testcase classname="tests.test_a2a_star_topology.TestStarTopologyEnforcement" name="test_star_requires_recipient" time="0.002" /><testcase classname="tests.test_a2a_star_topology.TestStarTopologyEnforcement" name="test_star_msg_id_format" time="0.002" /><testcase classname="tests.test_a2a_star_topology.TestStarTopologyEnforcement" name="test_star_uses_current_epoch" time="0.002" /><testcase classname="tests.test_a2a_star_topology.TestStarTopologyEnforcement" name="test_external_sender_in_star" time="0.002" /><testcase classname="tests.test_a2a_topology_switch_runtime.TestDynamicTopologySwitch" name="test_star_to_chain_switch_enforces_new_rules" time="0.003" /><testcase classname="tests.test_a2a_topology_switch_runtime.TestDynamicTopologySwitch" name="test_chain_to_flat_switch_changes_requirements" time="0.004" /><testcase classname="tests.test_a2a_topology_switch_runtime.TestDynamicTopologySwitch" name="test_flat_to_star_switch_enforces_hub_routing" time="0.003" /><testcase classname="tests.test_a2a_topology_switch_runtime.TestDynamicTopologySwitch" name="test_epoch_increments_with_topology_switch" time="0.003" /><testcase classname="tests.test_a2a_topology_switch_runtime.TestDynamicTopologySwitch" name="test_force_topology_override_for_testing" time="0.003" /><testcase classname="tests.test_a2a_topology_switch_runtime.TestDynamicTopologySwitch" name="test_concurrent_switches_use_correct_topology" time="0.003" /><testcase classname="tests.test_a2a_topology_switch_runtime.TestDynamicTopologySwitch" name="test_single_epoch_capture_per_send" time="0.003" /><testcase classname="tests.test_coordinator_dwell_cooldown" name="test_coordinator_dwell_and_cooldown_enforcement" time="0.001" /><testcase classname="tests.test_coordinator_dwell_cooldown" name="test_topology_changed_event_signaling" time="0.001" /><testcase classname="tests.test_defaults_config" name="test_defaults_values" time="0.000" /><testcase classname="tests.test_docs_m0_summaries" name="test_docs_m0_summaries_present" time="0.000" /><testcase classname="tests.test_evidence_pack_presence" name="test_evidence_pack_present_for_completed_milestones" time="0.000" /><testcase classname="tests.test_fs_local_whitelist_patch_search" name="test_fs_whitelist_read_write_and_escape" time="0.003" /><testcase classname="tests.test_fs_local_whitelist_patch_search" name="test_fs_patch_minimal_unified_diff" time="0.002" /><testcase classname="tests.test_fs_local_whitelist_patch_search" name="test_fs_search_files_content_regex" time="0.003" /><testcase classname="tests.test_fs_local_whitelist_patch_search" name="test_fs_search_files_ignores_symlink_escape" time="0.002" /><testcase classname="tests.test_llm_http_client" name="test_llm_http_success" time="0.005" /><testcase classname="tests.test_llm_http_client" name="test_llm_http_retry_on_5xx" time="0.003" /><testcase classname="tests.test_llm_http_client" name="test_llm_http_timeout" time="0.203" /><testcase classname="tests.test_llm_http_client" name="test_llm_http_no_retry_on_4xx" time="0.003" /><testcase classname="tests.test_makefile_targets" name="test_makefile_targets_and_tools" time="0.000" /><testcase classname="tests.test_mcp_fastmcp_wrappers.TestFastMCPServer" name="test_server_initialization" time="0.279" /><testcase classname="tests.test_mcp_fastmcp_wrappers.TestFastMCPServer" name="test_fs_tools_registered" time="0.005" /><testcase classname="tests.test_mcp_fastmcp_wrappers.TestFastMCPServer" name="test_fs_read_tool" time="0.004" /><testcase classname="tests.test_mcp_fastmcp_wrappers.TestFastMCPServer" name="test_fs_search_deterministic_order" time="0.004" /><testcase classname="tests.test_mcp_fastmcp_wrappers.TestFastMCPServer" name="test_whitelist_enforcement" time="0.005" /><testcase classname="tests.test_mcp_fastmcp_wrappers.TestFastMCPServer" name="test_test_tools_registered" time="0.004" /><testcase classname="tests.test_mcp_fastmcp_wrappers.TestFastMCPServer" name="test_server_stdio_transport" time="0.000"><skipped type="pytest.skip" message="MCP server disabled">/Users/sujeethjinesh/Desktop/APEXTopologyReconfiguration/tests/test_mcp_fastmcp_wrappers.py:103: MCP server disabled</skipped></testcase><testcase classname="tests.test_mcp_fastmcp_wrappers.TestFastMCPServer" name="test_server_requires_fastmcp" time="0.001" /><testcase classname="tests.test_mcp_fastmcp_wrappers.TestMCPServerIntegration" name="test_server_start_stop" time="0.004" /><testcase classname="tests.test_mcp_traversal_denial.TestMCPTraversalDenial" name="test_fs_read_blocks_traversal" time="0.005" /><testcase classname="tests.test_mcp_traversal_denial.TestMCPTraversalDenial" name="test_fs_write_blocks_traversal" time="0.004" /><testcase classname="tests.test_mcp_traversal_denial.TestMCPTraversalDenial" name="test_symlink_traversal_blocked" time="0.004" /><testcase classname="tests.test_mcp_traversal_denial.TestMCPTraversalDenial" name="test_search_respects_whitelist" time="0.005" /><testcase classname="tests.test_mcp_traversal_denial.TestMCPTraversalDenial" name="test_default_transport_is_stdio" time="0.003" /><testcase classname="tests.test_mcp_traversal_denial.TestMCPTraversalDenial" name="test_mcp_server_stdio_not_network" time="0.002" /><testcase classname="tests.test_message_dataclass" name="test_message_mutability_and_defaults" time="0.000" /><testcase classname="tests.test_msg_id_uniqueness_10k" name="test_10k_messages_unique_ids" time="0.333" /><testcase classname="tests.test_precommit_config" name="test_precommit_config_has_expected_hooks" time="0.000" /><testcase classname="tests.test_protocols_importable" name="test_protocols_defined_and_importable" time="0.000" /><testcase classname="tests.test_pytest_adapter_discover_run" name="test_pytest_adapter_discover_and_run" time="2.138" /><testcase classname="tests.test_router_fifo_ttl_retry" name="test_per_recipient_fifo_order" time="0.001" /><testcase classname="tests.test_router_fifo_ttl_retry" name="test_ttl_drop_on_dequeue" time="0.022" /><testcase classname="tests.test_router_fifo_ttl_retry" name="test_retry_increments_attempt_and_redelivered" time="0.001" /><testcase classname="tests.test_switch_epoch_gating_atomic" name="test_atomic_no_n_plus_one_dequeue_until_commit" time="0.002" /><testcase classname="tests.test_switch_epoch_gating_atomic" name="test_abort_reenqueue_fifo" time="0.052" /><testcase classname="tests.test_switch_epoch_gating_atomic" name="test_abort_tracks_drop_counts" time="0.053" /></testsuite></testsuites>